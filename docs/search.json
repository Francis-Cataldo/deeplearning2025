[
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "CSCI 1051: Syllabus",
    "section": "",
    "text": "Course Description: Deep learning has revolutionized our ability to solve complex problems, but its success often obscures the underlying principles that make it work. This course offers a structured approach to understanding and applying deep learning techniques, beginning with the theoretical foundations of linear and logistic regression. We will then generalize these ideas into a three-step deep learning framework (architecture, loss function, and optimizer). Applying this framework, we will explore modern generative methods like auto-regressive language models and diffusion. Because the tools we discuss are so powerful, it is important to understand their limitations. To this end, we will also cover techniques for interpreting deep learning predictions and adding safeguards to generated content.\nPrerequisites: I will assume familiarity with calculus, linear regression, probability, and Python. In particular, I will assume you are comfortable with derivatives, the chain rule, gradients, matrix multiplication, and probability distributions.\nStructure: We will meet on Monday, Tuesday, Wednesday, and Thursday at 75 Shannon in Room 202. The lecture is from 10am to 12pm and the discussion is from 2 to 4pm. I will hold my office hours during the last hour of the discussion. If you would like to meet outside of these times, please email me.\nResources: This class is loosely based on Chinmay Hegde’s phenomenal graduate Deep Learning course at NYU Tandon. For each class, I will post my handwritten slides. I would also like for you to be able to access curated notes. To this end, one of the assignments in the class is to scribe notes on a lecture of your choice.\nDiscussion: Please post all your course related questions on Canvas. If your question reveals your solution to a homework problem, please email me instead.\n\nGrading\nYour grade in the class will be based on the number of points you earn. You will receive an A if you earn 93 or more points, an A- if you earn between 90 and 92 points (inclusive), a B+ if you earn between 87 and 89 points (inclusive), etc.\nParticipation and Questions (13 points): Since winter term classes are smaller, let’s take advantage of the opportunity for more engagement. Unless you have a reasonable excuse (e.g. sickness, family emergency), I expect you to attend every lecture and discussion. Whether you are able to attend or not, I expect you to fill out the form linked from the home page to receive credit for engagement (one point per lecture day that you fill it out). Of course, if you are not able to attend in person, you should watch the recorded zoom lecture before filling out the form.\nProblem Sets (52 points): There will be one problem per class. You may work on the problems with your classmates. However, you should write your solutions and code by yourself.\nProject (30 points): In order to practice implementing the ideas we cover, you will select a topic we cover in class and implement an algorithm we discussed on a data set of your choosing. You will write a report describing your results and what you learned. You will also give a presentation showcasing your code to the class. You can complete your project as an individual or with a partner.\nScribed Notes (9 points): Notes are a great resource for augmenting your in-class learning. While I have notes for the prior iteration of this course, I since updated the topics in this course to account for much of the progress in deep learning in the last two years. Unfortunately, I haven’t had time to create a new set of notes to reflect the current content. As such, I would like to ask for your help in writing these notes. I will provide an example for the first class (including the finished product and the source). Thereafter, students can sign up on this sheet to write notes for a lecture of your choice. You will have access to my handwritten slides, a zoom recording of the lecture, and any generative model. Because I hope to use these notes in future iterations of the course (with appropriate acknowledgements, of course), I will grade the notes stringently and allow you to resubmit them once.\nLate Policy: I expect all assignments to be turned in on time. If you are unable to turn in an assignment on time, you must email me before the assignment is due to request an extension.\n\n\nHonor Code\nAcademic integrity is an important part of your learning experience. You are welcome to use online material and discuss problems with others but you must explicitly acknowledge the outside resources on the work you submit.\nIf I notice that you have copied someone else’s work without proper attribution (such as code from the internet without a reference link or a solution very close to another student’s without giving credit), I will give you a warning. After the warning, I will subtract 5 points for every violation.\nLarge Language Models: LLMs (that we learn about in class!) are a powerful tool. However, while they are very good at producing human-like text, they have no inherent sense of ‘correctness’. You may use LLMs (as detailed below) but you are wholly responsible for the material you submit.\nYou may use LLMs for:\n\nImplementing short blocks of code that you can easily check.\nSimple questions whose answers you can easily verify.\n\nDo not use LLMS for:\n\nImplementing extensive code or code that you don’t understand.\nComplicated questions (like those on the problem sets) that you would learn from answering yourself.\n\nUltimately, the point of the assignments in this class are for you to practice the concepts. If you use an LLM in lieu of practice, then you deny yourself the chance to learn.\n\n\nAcademic Accommodations\nIf you have a Letter of Accommodation, please contact me as early in the term as possible. If you do not have a Letter of Accommodation and you believe you are eligible, please reach out to the ADA Coordinators at ada@middlebury.edu."
  },
  {
    "objectID": "notes/code.html",
    "href": "notes/code.html",
    "title": "Code for Producing Images in Lecture Notes",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\n\nLinear Regression Figures\n\nnp.random.seed(1234) # Seed randomness\n\nn = 10 # Number of observations\nw = 2 # True parameter\nX = np.random.rand(n) # x-values\ny = X.dot(w).T + np.random.normal(size=n) * .2 #y-values\n\nplt.scatter(X,y, color='black', label=r'Data: $(x^{(i)}, y^{(i)})$')\nplt.xlabel(r'$x$')\nplt.ylabel(r'$y$')\nxaxis = np.arange(0,1,.01)\nplt.plot(xaxis, xaxis*.5, label=r'Line: $f(x) = .5x$', color='red')\nplt.plot(xaxis, xaxis*w, label=r'Line: $f(x) = 2x$', color='green')\nplt.legend()\nplt.title(r'Linear Regression in $\\mathbb{R}^1$')\nplt.savefig('images/regression_1d.pdf')\n\n\n\n\n\n\n\n\n\nplt.xlabel(r'$z$')\nplt.ylabel(r'$\\mathcal{L}(z)$')\nxaxis = np.arange(-1.5,1.5,.001)\nplt.plot(xaxis, xaxis**2, label=r'Squared Loss: $\\mathcal{L}(z)=z^2$', color='blue')\nplt.plot(xaxis, np.abs(xaxis), label=r'Absolute Loss: $\\mathcal{L}(z)=|z|$', color='purple', linestyle='dotted')\nplt.legend()\nplt.title(r'Squared and Absolute Losses')\nplt.savefig('images/regression_losses.pdf')\n\n\n\n\n\n\n\n\n\n# 3D version of this plot\nnp.random.seed(1234) # Seed randomness\nn = 10 # Number of observations\nw = np.array([2, .5]) # True parameter\nX = np.random.rand(n, 2) # x-values\ny = X.dot(w).T + np.random.normal(size=n) * .1 #y-values\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(X[:,1], X[:,1], y, color='black', label=r'Data: $(x_1^{(i)}, x_2^{(i)}, y^{(i)})$')\n\n# Hyperplane 1\nx1 = np.arange(0,1,.01)\nx2 = np.arange(0,1,.01)\nX1, X2 = np.meshgrid(x1, x2)\nZ = w[0]*X1 + w[1]*X2\nax.plot_surface(X1, X2, Z, alpha=.5, color='green', label=r'Hyperplane: $f(x) = 2x_1 + .5x_2$')\n\n# Hyperplane 2\nax.plot_surface(X1, X2, .5*X1+0*X2, alpha=.5, color='red', label=r'Hyperplane: $f(x) = .5x_1 + 0x_2 $')\n\nax.set_xlabel(r'$x_1$')\nax.set_ylabel(r'$x_2$')\n# Add label to the z-axis\nax.set_zlabel(r'$y$')\n\nax.set_title(r'Linear Regression in $\\mathbb{R}^2$')\nplt.legend(loc='upper left', framealpha=1)\nplt.savefig('images/regression_2d.pdf', bbox_inches='tight')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CSCI 1051: Deep Learning",
    "section": "",
    "text": "Deep learning from theoretical foundations to state-of-the-art applications.\n\n\n\n\nInstructor: R. Teal Witter. Please call me Teal.\nClass Times: We meet Monday, Tuesday, Wednesday, and Thursday in 75 Shannon St Room 202. The lecture is from 10am to noon and the discussion is from 2 to 4pm.\nOffice Hours: I will hold office hours in 75 Shannon St Room 221 from 3 to 4pm.\nParticipation: I expect you to engage in class, ask questions, and make connections. So I can check in with you, please fill out this form every lecture.\nScribed Notes: Notes are a great resource for augmenting your in-class learning. Since I updated the material in this course, I would like to ask for your help in writing these notes. You can find the assignment here.\n\n\nAssignments: You will receive one problem per class. I expect you to solve the problem with your group during the discussion (I’ll be there to answer questions). Once you have solved the problem, you should write up your solution on your own. In addition, there will be a project on a lecture topic of your choice.\n\n\n\nAssignment\n\n\nDue\n\n\n\n\nProblem Set 1 (LaTeX)\n\n\nFriday 1/10\n\n\n\n\nProblem Set 2\n\n\nFriday 1/17\n\n\n\n\nProblem Set 3\n\n\nFriday 1/24\n\n\n\n\nProblem Set 4\n\n\nWednesday 1/29\n\n\n\n\nProject Proposal\n\n\nWednesday 1/22\n\n\n\n\nProject\n\n\nFriday 1/31\n\n\n\n\n\n\n\n\nClass\n\n\nTopic\n\n\nSlides\n\n\nResources\n\n\n\n\nThe Three-Step Framework\n\n\n\n\nMonday 1/6\n\n\nLinear Regression and Mean Squared Error\n\n\nSlides\n\n\nNotes\n\n\n\n\nTuesday 1/7\n\n\nLogistic Regression and Cross Entropy Loss\n\n\n\n\n\n\n\n\nWednesday 1/8\n\n\nGradient Descent and Neural Networks\n\n\n\n\n\n\n\n\nThursday 1/9\n\n\nBack-propagation and Optimization\n\n\n\n\n\n\n\n\nLanguage Generation\n\n\n\n\nMonday 1/13\n\n\nLanguage Embeddings and Contrastive Loss\n\n\n\n\n\n\n\n\nTuesday 1/14\n\n\nTransformers and Positional Encoding\n\n\n\n\n\n\n\n\nWednesday 1/15\n\n\nLarge Language Models\n\n\n\n\n\n\n\n\nThursday 1/16\n\n\nFinetuning\n\n\n\n\n\n\n\n\nImage Generation\n\n\n\n\nTuesday 1/21\n\n\nConvolutional Neural Networks and Image Embeddings\n\n\n\n\n\n\n\n\nWednesday 1/22\n\n\nDiffusion\n\n\n\n\n\n\n\n\nThursday 1/23\n\n\nSchrödinger Bridges\n\n\n\n\n\n\n\n\nAI Safety\n\n\n\n\nMonday 1/27\n\n\nInterpretability\n\n\n\n\n\n\n\n\nTuesday 1/28\n\n\nWatermarking\n\n\n\n\n\n\n\n\nWednesday 1/29\n\n\nProject Preparation\n\n\n\n\n\n\n\n\nThursday 1/30\n\n\nProject Presentations"
  },
  {
    "objectID": "notes/01_regression.html",
    "href": "notes/01_regression.html",
    "title": "Linear Regression and Mean Squared Error",
    "section": "",
    "text": "When I first heard about machine learning, I imagined a computer that was rewarded every time it gave the right answer. Maybe there were electric carrots and sticks that no one had bothered to tell me about? While I now know as little as I did then about computer hardware, I have learned that machine learning is fundamentally a mathematical process.\nLuckily, we’ve been learning about the very mathematical ideas that make machine learning work for years! We’ll review the basics of these concepts and then jump in to linear regression, arguably the foundation of neural networks.\n\n\nImagine a function \\(\\mathcal{L}: \\mathbb{R} \\to \\mathbb{R}\\). (Instead of the usual \\(f\\), we’ll use \\(\\mathcal{L}\\) for reasons that will soon become clear.) The mapping notation means that \\(\\mathcal{L}\\) takes a single real number as input and outputs a single real number. In general, mathematicians tell us to be careful about whether we can differentiate a function. But, we’re computer scientists so we’ll risk it for the biscuit.\nLet \\(z \\in \\mathbb{R}\\) be the input to \\(\\mathcal{L}\\). The derivative of \\(\\mathcal{L}\\) with respect to its input \\(z\\) is mathematically denoted by \\(\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\\).\nFormally, the derivative is defined as \\[\n\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\n= \\lim_{h \\to 0} \\frac{\\mathcal{L}(z + h) - \\mathcal{L}(z)}{h}.\n\\] If we were to plot \\(\\mathcal{L}\\), the derivative at a point \\(z\\) would be the slope of the tangent line to the curve at that point.\nHere are several examples of functions and their derivatives that you might remember from calculus.\n\n\n\nFunction: \\(\\mathcal{L}(z)\\) \n\n\nDerivative: \\(\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\\)\n\n\n\n\n\\[z^2\\]\n\n\n\\[2z\\]\n\n\n\n\n\\[z^a\\]\n\n\n\\[a z^{a-1}\\]\n\n\n\n\n\\[az + b\\]\n\n\n\\[a\\]\n\n\n\n\n\\[\\ln(z)\\]\n\n\n\\[\\frac{1}{z}\\]\n\n\n\n\n\\[e^z\\]\n\n\n\\[e^z\\]\n\n\n\n\n\n\nWhile working with a simple basic function is easy, we’re not always so lucky. Modern machine learning chains many many complicated functions together. Fortunately, we will think of these operations modularly.\nLet \\(g: \\mathbb{R} \\to \\mathbb{R}\\) be another function. Consider the composite function \\(g(\\mathcal{L}(z))\\).\nBy the chain rule, the derivative of \\(g(\\mathcal{L}(z))\\) with respect to \\(z\\) is \\[\n\\frac{\\partial }{\\partial z}[g(\\mathcal{L}(z))]\n= \\frac{\\partial g}{\\partial z}(\\mathcal{L}(z))\n\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)].\n\\]\nOften, we will also multiply functions together. The product rule tells us that \\[\n\\frac{\\partial }{\\partial z}[g(z) \\mathcal{L}(z)]\n= g(z) \\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\n+ \\mathcal{L}(z) \\frac{\\partial}{\\partial z}[g(z)].\n\\]\n\n\n\nIn machine learning, we process high-dimensional data so we are interested in functions with multivariate input. Consider \\(\\mathcal{L}: \\mathbb{R}^d \\to \\mathbb{R}\\). The output of the function is still a real number but the input consists of \\(d\\) real numbers. We will use the vector \\(\\mathbf{z} \\in \\mathbb{R}^d\\) to represent all \\(d\\) inputs \\(z_1, \\ldots, z_d\\).\nInstead of the derivative, we will talk use the partial derivative. The partial derivative with respect to \\(z_i\\) is denoted by \\(\\frac{\\partial}{\\partial z_i}[\\mathcal{L}(\\mathbf{z})]\\). In effect, the partial derivative tells us how \\(\\mathcal{L}\\) changes when we change \\(z_i\\) while keeping all other inputs fixed.\nThe gradient stores all the partial derivatives in a vector. The \\(i\\)th entry of this vector is given by the partial derivative of \\(\\mathcal{L}\\) with respect to \\(z_i\\). In mathematical notation, \\[\n\\nabla_\\mathbf{z} \\mathcal{L} = \\left[\\begin{smallmatrix} \\frac{\\partial}{\\partial z_1}[\\mathcal{L}(\\mathbf{z})] \\\\ \\vdots \\\\ \\frac{\\partial}{\\partial z_d}[\\mathcal{L}(\\mathbf{z})] \\\\ \\end{smallmatrix}\\right]\n\\]\nJust like the derivative in one dimension, the gradient contains information about the slope of \\(\\mathcal{L}\\) with respect to each of the \\(d\\) dimensions in its input.\n\n\n\nVector and matrix multiplication lives at the heart of deep learning. In fact, deep learning really started to take off when researchers realized that the Graphical Processing Unit (GPU) could be used to perform gradient updates in addition to the matrix multiplication it was designed to do for gaming.\nConsider two vectors \\(\\mathbf{u} \\in \\mathbb{R}^d\\) and \\(\\mathbf{v} \\in \\mathbb{R}^d\\). We will use \\(\\mathbf{u} \\cdot \\mathbf{v} = \\sum_{i=1}^d u_i v_i\\) to denote the inner product of \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\). The \\(\\mathcal{\\ell}_2\\)-norm of \\(v\\) is given by \\(\\|\\mathbf{v}\\|_2 = \\sqrt{\\mathbf{u} \\cdot \\mathbf{u}}\\).\nConsider two matrices: \\(\\mathbf{A} \\in \\mathbb{R}^{d \\times m}\\) and \\(\\mathbf{B} \\in \\mathbb{R}^{m \\times n}\\) where \\(d \\neq n\\). We can only multiply two matrices when their inner dimension agrees. Because the number of columns in \\(\\mathbf{A}\\) is the same as the number of rows in \\(\\mathbf{B}\\), we can compute \\(\\mathbf{AB}\\). However, because the number of columns in \\(\\mathbf{B}\\) is not the same as the number of rows in \\(\\mathbf{A}\\), the product \\(\\mathbf{BA}\\) is not defined.\nWhen we can multiply two matrices, the \\((i,j)\\) entry in \\(\\mathbf{AB}\\) is given by the inner product between the \\(i\\)th row of \\(\\mathbf{A}\\) and the \\(j\\)th column of \\(\\mathbf{B}\\). The resulting dimensions of the matrix product will be the number of rows in \\(\\mathbf{A}\\) by the number of columns in \\(\\mathbf{B}\\).\n\n\n\nIf we have a scalar equation \\(ax = b\\), we can simply solve for \\(x\\) by dividing both sides by \\(a\\). In effect, we are applying the inverse of \\(a\\) to \\(a\\) i.e., \\(\\frac1{a} a =1\\). The same principle applies to matrices. The \\(n \\times n\\) identity matrix generalizes the scalar identity \\(1\\). This identity matrix is denoted by \\(\\mathbf{I}_{n \\times n} \\in \\mathbb{R}^{n \\times n}\\): the on-diagonal entries \\((i,i)\\) are 1 while the off-diagonal entries \\((i,j)\\) for \\(i\\neq j\\) are 0.\nConsider the matrix equation \\(\\mathbf{Ax} = \\mathbf{b}\\) where \\(\\mathbf{A} \\in \\mathbb{R}^{d \\times d}\\), \\(\\mathbf{x} \\in \\mathbb{R}^d\\), and \\(\\mathbf{b} \\in \\mathbb{R}^d\\). (Notice that the inner dimensions of \\(\\mathbf{A}\\) and \\(\\mathbf{x}\\) agree so their multiplication is well-defined, and the resulting vector is the same dimension as \\(\\mathbf{b}\\).)\nIf we want to solve for \\(\\mathbf{x}\\), we can use the matrix inverse. For a matrix \\(\\mathbf{A}\\), we use \\(\\mathbf{A}^{-1}\\) to denote its inverse. The inverse is defined so that \\(\\mathbf{A}^{-1} \\mathbf{A} = \\mathbf{I}_{n \\times n}\\) where \\(\\mathbf{I}_{n \\times n}\\) is the identity matrix. Then, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by \\(\\mathbf{A}^{-1}\\). \\[\n\\mathbf{A}^{-1} \\mathbf{Ax} = \\mathbf{A}^{-1} \\mathbf{b}\n\\] Since \\(\\mathbf{A}^{-1} \\mathbf{A} = \\mathbf{I}_{n \\times n}\\), we have that \\(\\mathbf{I}_{n \\times n} \\mathbf{x} = \\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b}\\)."
  },
  {
    "objectID": "notes/01_regression.html#math-review",
    "href": "notes/01_regression.html#math-review",
    "title": "Linear Regression and Mean Squared Error",
    "section": "",
    "text": "When I first heard about machine learning, I imagined a computer that was rewarded every time it gave the right answer. Maybe there were electric carrots and sticks that no one had bothered to tell me about? While I now know as little as I did then about computer hardware, I have learned that machine learning is fundamentally a mathematical process.\nLuckily, we’ve been learning about the very mathematical ideas that make machine learning work for years! We’ll review the basics of these concepts and then jump in to linear regression, arguably the foundation of neural networks.\n\n\nImagine a function \\(\\mathcal{L}: \\mathbb{R} \\to \\mathbb{R}\\). (Instead of the usual \\(f\\), we’ll use \\(\\mathcal{L}\\) for reasons that will soon become clear.) The mapping notation means that \\(\\mathcal{L}\\) takes a single real number as input and outputs a single real number. In general, mathematicians tell us to be careful about whether we can differentiate a function. But, we’re computer scientists so we’ll risk it for the biscuit.\nLet \\(z \\in \\mathbb{R}\\) be the input to \\(\\mathcal{L}\\). The derivative of \\(\\mathcal{L}\\) with respect to its input \\(z\\) is mathematically denoted by \\(\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\\).\nFormally, the derivative is defined as \\[\n\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\n= \\lim_{h \\to 0} \\frac{\\mathcal{L}(z + h) - \\mathcal{L}(z)}{h}.\n\\] If we were to plot \\(\\mathcal{L}\\), the derivative at a point \\(z\\) would be the slope of the tangent line to the curve at that point.\nHere are several examples of functions and their derivatives that you might remember from calculus.\n\n\n\nFunction: \\(\\mathcal{L}(z)\\) \n\n\nDerivative: \\(\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\\)\n\n\n\n\n\\[z^2\\]\n\n\n\\[2z\\]\n\n\n\n\n\\[z^a\\]\n\n\n\\[a z^{a-1}\\]\n\n\n\n\n\\[az + b\\]\n\n\n\\[a\\]\n\n\n\n\n\\[\\ln(z)\\]\n\n\n\\[\\frac{1}{z}\\]\n\n\n\n\n\\[e^z\\]\n\n\n\\[e^z\\]\n\n\n\n\n\n\nWhile working with a simple basic function is easy, we’re not always so lucky. Modern machine learning chains many many complicated functions together. Fortunately, we will think of these operations modularly.\nLet \\(g: \\mathbb{R} \\to \\mathbb{R}\\) be another function. Consider the composite function \\(g(\\mathcal{L}(z))\\).\nBy the chain rule, the derivative of \\(g(\\mathcal{L}(z))\\) with respect to \\(z\\) is \\[\n\\frac{\\partial }{\\partial z}[g(\\mathcal{L}(z))]\n= \\frac{\\partial g}{\\partial z}(\\mathcal{L}(z))\n\\frac{\\partial}{\\partial z}[\\mathcal{L}(z)].\n\\]\nOften, we will also multiply functions together. The product rule tells us that \\[\n\\frac{\\partial }{\\partial z}[g(z) \\mathcal{L}(z)]\n= g(z) \\frac{\\partial}{\\partial z}[\\mathcal{L}(z)]\n+ \\mathcal{L}(z) \\frac{\\partial}{\\partial z}[g(z)].\n\\]\n\n\n\nIn machine learning, we process high-dimensional data so we are interested in functions with multivariate input. Consider \\(\\mathcal{L}: \\mathbb{R}^d \\to \\mathbb{R}\\). The output of the function is still a real number but the input consists of \\(d\\) real numbers. We will use the vector \\(\\mathbf{z} \\in \\mathbb{R}^d\\) to represent all \\(d\\) inputs \\(z_1, \\ldots, z_d\\).\nInstead of the derivative, we will talk use the partial derivative. The partial derivative with respect to \\(z_i\\) is denoted by \\(\\frac{\\partial}{\\partial z_i}[\\mathcal{L}(\\mathbf{z})]\\). In effect, the partial derivative tells us how \\(\\mathcal{L}\\) changes when we change \\(z_i\\) while keeping all other inputs fixed.\nThe gradient stores all the partial derivatives in a vector. The \\(i\\)th entry of this vector is given by the partial derivative of \\(\\mathcal{L}\\) with respect to \\(z_i\\). In mathematical notation, \\[\n\\nabla_\\mathbf{z} \\mathcal{L} = \\left[\\begin{smallmatrix} \\frac{\\partial}{\\partial z_1}[\\mathcal{L}(\\mathbf{z})] \\\\ \\vdots \\\\ \\frac{\\partial}{\\partial z_d}[\\mathcal{L}(\\mathbf{z})] \\\\ \\end{smallmatrix}\\right]\n\\]\nJust like the derivative in one dimension, the gradient contains information about the slope of \\(\\mathcal{L}\\) with respect to each of the \\(d\\) dimensions in its input.\n\n\n\nVector and matrix multiplication lives at the heart of deep learning. In fact, deep learning really started to take off when researchers realized that the Graphical Processing Unit (GPU) could be used to perform gradient updates in addition to the matrix multiplication it was designed to do for gaming.\nConsider two vectors \\(\\mathbf{u} \\in \\mathbb{R}^d\\) and \\(\\mathbf{v} \\in \\mathbb{R}^d\\). We will use \\(\\mathbf{u} \\cdot \\mathbf{v} = \\sum_{i=1}^d u_i v_i\\) to denote the inner product of \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\). The \\(\\mathcal{\\ell}_2\\)-norm of \\(v\\) is given by \\(\\|\\mathbf{v}\\|_2 = \\sqrt{\\mathbf{u} \\cdot \\mathbf{u}}\\).\nConsider two matrices: \\(\\mathbf{A} \\in \\mathbb{R}^{d \\times m}\\) and \\(\\mathbf{B} \\in \\mathbb{R}^{m \\times n}\\) where \\(d \\neq n\\). We can only multiply two matrices when their inner dimension agrees. Because the number of columns in \\(\\mathbf{A}\\) is the same as the number of rows in \\(\\mathbf{B}\\), we can compute \\(\\mathbf{AB}\\). However, because the number of columns in \\(\\mathbf{B}\\) is not the same as the number of rows in \\(\\mathbf{A}\\), the product \\(\\mathbf{BA}\\) is not defined.\nWhen we can multiply two matrices, the \\((i,j)\\) entry in \\(\\mathbf{AB}\\) is given by the inner product between the \\(i\\)th row of \\(\\mathbf{A}\\) and the \\(j\\)th column of \\(\\mathbf{B}\\). The resulting dimensions of the matrix product will be the number of rows in \\(\\mathbf{A}\\) by the number of columns in \\(\\mathbf{B}\\).\n\n\n\nIf we have a scalar equation \\(ax = b\\), we can simply solve for \\(x\\) by dividing both sides by \\(a\\). In effect, we are applying the inverse of \\(a\\) to \\(a\\) i.e., \\(\\frac1{a} a =1\\). The same principle applies to matrices. The \\(n \\times n\\) identity matrix generalizes the scalar identity \\(1\\). This identity matrix is denoted by \\(\\mathbf{I}_{n \\times n} \\in \\mathbb{R}^{n \\times n}\\): the on-diagonal entries \\((i,i)\\) are 1 while the off-diagonal entries \\((i,j)\\) for \\(i\\neq j\\) are 0.\nConsider the matrix equation \\(\\mathbf{Ax} = \\mathbf{b}\\) where \\(\\mathbf{A} \\in \\mathbb{R}^{d \\times d}\\), \\(\\mathbf{x} \\in \\mathbb{R}^d\\), and \\(\\mathbf{b} \\in \\mathbb{R}^d\\). (Notice that the inner dimensions of \\(\\mathbf{A}\\) and \\(\\mathbf{x}\\) agree so their multiplication is well-defined, and the resulting vector is the same dimension as \\(\\mathbf{b}\\).)\nIf we want to solve for \\(\\mathbf{x}\\), we can use the matrix inverse. For a matrix \\(\\mathbf{A}\\), we use \\(\\mathbf{A}^{-1}\\) to denote its inverse. The inverse is defined so that \\(\\mathbf{A}^{-1} \\mathbf{A} = \\mathbf{I}_{n \\times n}\\) where \\(\\mathbf{I}_{n \\times n}\\) is the identity matrix. Then, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by \\(\\mathbf{A}^{-1}\\). \\[\n\\mathbf{A}^{-1} \\mathbf{Ax} = \\mathbf{A}^{-1} \\mathbf{b}\n\\] Since \\(\\mathbf{A}^{-1} \\mathbf{A} = \\mathbf{I}_{n \\times n}\\), we have that \\(\\mathbf{I}_{n \\times n} \\mathbf{x} = \\mathbf{x} = \\mathbf{A}^{-1} \\mathbf{b}\\)."
  },
  {
    "objectID": "notes/01_regression.html#univariate-linear-regression",
    "href": "notes/01_regression.html#univariate-linear-regression",
    "title": "Linear Regression and Mean Squared Error",
    "section": "Univariate Linear Regression",
    "text": "Univariate Linear Regression\nNow that we’ve reviewed the basic building blocks of machine learning, we can dive into linear regression. Linear regression is a simple and powerful tool that we will use to understand the basics of deep learning.\n\nGoal\nWe will begin our study of deep learning in the supervised setting. In this setting, we are given labelled data with input features and an outcome. Formally, we will have \\(n\\) labelled observations \\((x^{(1)}, y^{(1)}), \\ldots, (x^{(n)}, y^{(n)})\\). In general, we will have \\(y \\in \\mathbb{R}\\). For simplicity, we will assume for now that \\(x \\in \\mathbb{R}\\).\nOur goal is to process the data and learn a function that approximates the outcomes. In mathematical notation, we want to learn a function \\(f: \\mathbb{R} \\to \\mathbb{R}\\) so that \\(f(x^{(i)}) \\approx y^{(i)}\\) for the \\(n\\) labelled observations \\(i \\in \\{1,\\ldots,n\\}\\).\nBefore we dive into the specific way we will accomplish this with linear regression, let’s discuss the general deep learning framework. This three-step framework gives a flexible scaffolding that we will use to understand almost every topic in this course.\nThe three-step framework includes:\n• The Model: The function that we’ll use to process the input and produce a corresponding output.\n• The Loss: The function that measures the quality of the outputs from our model. (Without loss of generality, we will assume that lower is better.)\n• The Optimizer: The method of updating the model to improve the loss.\nWith these general concepts in mind, we’ll explore linear regression.\n\n\nLinear Model\nAs its name suggests, linear regression uses a linear model to process the input into an approximation of the output. Let \\(w \\in \\mathbb{R}\\) be a weight parameter. The linear model (for one-dimensional inputs) is given by \\(f(x) = wx\\).\nUnlike many deep learning models, we can visualize the linear model since it is given by a line. In the plot, we have the \\(n=10\\) data points plotted in 2 dimensions. There is one linear model \\(f(x) = 2x\\) that closely approximates the data and another linear model \\(f(x)=\\frac12 x\\) that does not approximate the data.\n\n\n\nOur goal is to learn how to find a linear model that fits the data well. Before we can do this though, we will need to define what it means for a model to “fit the data well”.\n\n\nMean Squared Error Loss\nOur goal for the loss function is to measure how closely the data fits the prediction made by our model. Intuitively, we should take the difference between the prediction and the true outcome \\(f(x^{(i)})-y^{(i)}\\).\nThe issue with this approach is that \\(f(x^{(i)})-y^{(i)}\\) can be small (negative) even when \\(f(x^{(i)}) \\neq y^{(i)}\\). A natural fix is to take the absolute value \\(|f(x^{(i)}) - y^{(i)}|\\). The benefit of the absolute value is that the loss is \\(0\\) if and only if \\(f(x^{(i)}) = y^{(i)}\\). However, the absolute value function is not differentiable, which is a property we’ll need for optimization. Instead, we use the squared loss:\n\\(\\mathcal{L}(w) = \\frac1{n} \\sum_{i=1}^n (f(x^{(i)}) - y^{(i)})^2\\)\nHere, we use the mean squared error loss, which is the average squared difference between the prediction and the true output over the dataset. Unlike the absolute value function, the squared function is differentiable everywhere. In addition, the squared error penalizes predictions that are far from the true output even more.\n\n\n\nThe plot above compares the squared function to the absolute value function. While both are \\(0\\) if and only if their input is \\(0\\), the squared function is differentiable everywhere and penalizes large errors more.\n\n\nExact Optimization\nWe now have our model and loss function: the linear model and mean squared error loss. The question becomes how to update the weights of the model to minimize the loss. In particular, we want to find \\(w\\) that minimizes \\(\\mathcal{L}(w)\\). While the language we’re using is new, the problem is not. We’ve actually been studying how to do this since pre-calculus!\nThe squared loss is convex (a bowl facing up versus the downward facing cave of concave); see the plot above for a ‘proof’ by picture. In this case, we know there is only one minimum. Not only that but we can find the minimum by setting the derivative to \\(0\\)!\nAs such, our game plan is to set \\(\\frac{\\partial \\mathcal{L}}{\\partial w}\\) to \\(0\\) and solve for \\(w\\). Recall that \\(f(x) = wx\\). We will use the linearity of the derivative, the chain rule, and the power rule to compute the derivative of \\(\\mathcal{L}\\) with respect to \\(w\\):\n\\[\n\\frac{\\partial}{\\partial w}[\\mathcal{L}(w)]\n= \\frac1{n} \\sum_{i=1}^n \\frac{\\partial}{\\partial w} [(f(x^{(i)}) - y^{(i)})^2]\n= \\frac1{n} \\sum_{i=1}^n 2(f(x^{(i)}) - y^{(i)}) \\frac{\\partial}{\\partial w} [(f(x^{(i)}) - y^{(i)})]\n= \\frac1{n} \\sum_{i=1}^n 2(w x^{(i)} - y^{(i)}) x^{(i)}.\n\\]\nSetting the derivative to \\(0\\) and solving for \\(w\\), we get \\(\\frac2{n} \\sum_{i=1}^n w (x^{(i)})^2 = \\frac2{n} \\sum_{i=1}^n y^{(i)} x^{(i)}\\) and so \\[\nw = \\frac{\\sum_{i=1}^n y^{(i)}}{\\sum_{i=1}^n (x^{(i)})^2}.\n\\]\nThis is the exact solution to the univariate linear regression problem! We can now use this formula to find the best linear model for our data. But we’re not done with linear regression yet. We assumed that the input was one-dimensional; however, we often have high-dimensional data."
  },
  {
    "objectID": "notes/01_regression.html#multivariate-linear-regression",
    "href": "notes/01_regression.html#multivariate-linear-regression",
    "title": "Linear Regression and Mean Squared Error",
    "section": "Multivariate Linear Regression",
    "text": "Multivariate Linear Regression\nConsider the more general setting where the input is \\(d\\)-dimensional. As before, we observe \\(n\\) training observations \\((\\mathbf{x}^{(1)}, y^{(1)}), \\ldots, (\\mathbf{x}^{(n)}, y^{(n)})\\) but now \\(\\mathbf{x}^{(i)} \\in \\mathbb{R}^d\\). We will generalize the ideas from univariate linear regression to the multivariate setting.\n\nLinear Model\nInstead of using a single weight \\(w \\in \\mathbb{R}\\), we will use \\(d\\) weights \\(\\mathbf{w} \\in \\mathbb{R}^d\\). Then the model is given by \\(f(x) = \\mathbf{w} \\cdot \\mathbf{x}\\).\nInstead of using a line to fit the data, we use a hyperplane. While visualizing the model is difficult in high dimensions, we can still see the model when \\(d=2\\).\n\n\n\nIn the plot above, we have \\(n=10\\) data points in 3 dimensions. There is one linear model \\(f(\\mathbf{x}) = \\begin{bmatrix} 2 \\\\ \\frac12 \\end{bmatrix} \\cdot \\mathbf{x}\\) that closely approximates the data and another linear model \\(f(\\mathbf{x}) = \\begin{bmatrix} \\frac12 \\\\ 0 \\end{bmatrix} \\cdot \\mathbf{x}\\) that does not approximate the data.\n\n\nMean Squared Error\nSince the output of \\(f\\) is still a single real number, we do not have to change the loss function. However, we can use our linear algebra notation to write the mean squared error in an elegant way.\nLet \\(\\mathbf{X} \\in \\mathbb{R}^{n \\times d}\\) be the data matrix where the \\(i\\)th row is \\((\\mathbf{x}^{(i)})^\\top\\). Similarly, let \\(\\mathbf{y} \\in \\mathbf{R}^n\\) be the target vector where the \\(i\\)th entry is \\(y^{(i)}\\). We can write the mean squared error loss as \\[\n\\mathcal{L}(\\mathbf{w}) = \\frac1{n} \\| \\mathbf{X w - y} \\|_2^2.\n\\]\n\n\nExact Optimization\nJust like computing the derivative and setting it to \\(0\\), we can compute the gradient and set it to the zero vector \\(\\mathbf{0} \\in \\mathbb{R}^d\\). In mathematical notation, we will set \\(\\nabla_\\mathbf{w} \\mathcal{L}(\\mathbf{w}) = \\mathbf{0}\\) and solve for \\(\\mathbf{w}\\).\nWe will leave this as an exercise on the homework. The final solution is that \\(\\mathbf{w} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}\\).\nThis is the exact solution to the multivariate linear regression problem!"
  },
  {
    "objectID": "notes/01_regression.html#conclusion",
    "href": "notes/01_regression.html#conclusion",
    "title": "Linear Regression and Mean Squared Error",
    "section": "Conclusion",
    "text": "Conclusion\nWe’ve learned about the basic building blocks of machine learning and used them to understand linear regression. We’ve seen how to define the model, loss, and optimizer. We’ve also seen how to solve the linear regression problem in both the univariate and multivariate settings.\nThere are two big questions that our discussion of linear regression raises:\n\nWhat if the data does not have a linear relationship?\nWhat happens when our model is too complex to solve for the exact solution?\n\nWe will answer these questions in future lectures as we explore logistic regression, neural networks, and gradient descent."
  }
]